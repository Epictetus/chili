{"body":"# Chili\r\n\r\nHave you ever wanted to test out a new feature on only a subset of users?\r\nDid that implementation end up being lots of if/else statements embedded in the main code?\r\nIf so, Chili can help.\r\n\r\nChili is built on top of Rails Engines and Deface and allows you to conditionally add new/modify existing views, while leaving the main code untouched.\r\n\r\n## Installation\r\n\r\nFirst add Chili to your app's Gemfile:\r\n\r\n```ruby\r\ngem 'chili'\r\n```\r\n\r\nand run `bundle`.\r\n\r\n## Usage\r\n\r\nThe easiest way to explain how Chili works is through an example. Lets say we have a site were people can submit posts about their travel experiences:\r\n\r\nIt is hard to tell which posts are interesting so we decide to test out a new \"Like\" feature where users can like certain posts and see which are popular. \r\n\r\nWant to test out this feature only for a set of beta testers \r\n\r\nOne way of doing it would be something like this:\r\n\r\n```erb\r\n<% # posts/_post.html.erb %>\r\n<tr>                                                                                                                                                                                                                                                                                                                      \r\n  <td><%= post.title %></td>\r\n  <% if logged_in? && current_user.beta_tester? %>\r\n    <td><%= link_to 'Like!', likes_path(like: {post_id: post}), method: :post %></td>\r\n  <% end %>\r\n</tr> \r\n```\r\n\r\nHowever, adding conditionals in the code like this can quickly become unmaintainable as more features are added and removing them from the main code is also a pain should we decide not to release the feature after all. Also, what about the likes_controller? How do we make sure that non-beta testers can't access this?\r\n\r\n\r\nChili extensions are like mini apps that are created inside your main app's vendor directory using using the \"chili\" generator.\r\n\r\n### Creating a new chili extension\r\n\r\nAs an example, assuming you want to add a new extension named \"social\" that exposes a new feature in the form of a like-button\r\nto a subset of users, first within your main app run:\r\n\r\n    $ rails g chili:extension social\r\n\r\nThis will:\r\n\r\n1. Create the directory `vendor/chili/social_extension` containing the basic structure for the extension\r\n2. Add a reference to the extension to the main app gemfile\r\n\r\nSince the extension is mounted as a gem you'll have to restart the app.\r\n\r\n### Define who can see the extension\r\n\r\nUse the active_if block to control whether new the extension is active for each user.\r\nThe context of the active_if block is the application controller so you can use any methods available to that.\r\n\r\n```ruby\r\n# lib/social_extension.rb\r\nmodule SocialExtension\r\n  extend Chili::Activatable\r\n  active_if { logged_in? && current_user.admin? } # Extension is only visible to logged in admin users\r\nend\r\n```\r\n\r\n### Modifying view templates in main app\r\n\r\nChili uses Deface to dynamically modify existing view templates (see [Deface docs](https://github.com/railsdog/deface#using-the-deface-dsl-deface-files) for details)\r\nAdd overrides to the `app/overides` directory mirroring the path of the view you want to modify.\r\nFor example, assuming the main app has the partial `app/views/posts/_post.html.erb`:\r\n\r\n```erb\r\n<% # app/overrides/posts/_post/like_button.html.erb.deface (folder should mirror main app view path) %>\r\n<!-- insert_bottom 'tr' -->\r\n<td><%= link_to 'Like!', social_extension.likes_path(like: {post_id: post}), method: :post %></td>\r\n```\r\n\r\n### Adding new resources\r\n\r\nRun `rails g scaffold Like` from within the extension's directory. The new resource will be namespaced to `SocialExtension::Like`\r\nand automounted as an [isolated engine](http://railscasts.com/episodes/277-mountable-engines?view=asciicast) in the main app at `/chili/social_extension/likes`, \r\nbut will only be accessible when active_if is true.\r\n\r\n### Migrations\r\n\r\nMigrations are handled the same way as engines. Use the\r\nfollowing commands after you've added a new migration to your extension:\r\n\r\n    $ rake social_extension:migrations:install\r\n    $ rake db:migrate\r\n\r\n### Modifying existing models\r\n\r\nCreate a model with the same name as the one you want to modify by running: `rails g model User --migration=false` inside your extension's directory\r\nand edit it to inherit from the original:\r\n\r\n```ruby\r\n# app/models/social_extension/user.rb\r\nmodule SocialExtension\r\n  class User < ::User\r\n    has_many :likes\r\n  end\r\nend\r\n```\r\n\r\nAccess in your overrides/extension views through the namespaced model:\r\n\r\n```erb\r\n<%= SocialExtension::User.first.likes %>\r\n<%= current_user.becomes(SocialExtension::User).likes %>\r\n```\r\n\r\n### Stylesheets/javascripts\r\n\r\nFiles added to the extension's `app/assets/social_extension/javascripts|stylesheets` directory are automatically injected into the layout using a pre-generated override:\r\n\r\n```erb\r\n<% # app/overrides/layouts/application/assets.html.erb.deface %>\r\n<!-- insert_bottom 'head' -->\r\n<%= stylesheet_link_tag 'social_extension/application' %>\r\n<%= javascript_include_tag 'social_extension/application' %>\r\n```\r\n\r\nIf you don't need any css/js in your extension, you can remove this file.\r\n\r\n## Gotchas\r\n\r\n- Chili will not be able to automount if you use a catch-all route in your main app (ie `match '*a', to: 'errors#routing'`), you will have to remove the catch-all or manually add the engine to the main app's routes file.\r\n- Just like normal engines, Chili requires you to prepend path helpers with `main_app` (ie `main_app.root_path` etc) in view templates that are shared with the main app (such as the main app's application layout file).","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"The spicy extension framework for Rails","name":"Chili","google":""}